use std::{io::stdout, path::PathBuf};

use anyhow::{bail, Result};
use clap::Args;
use ds_rom::{
    crypto::blowfish::BlowfishKey,
    rom::{Rom, RomLoadOptions, RomSaveError},
};

/// Builds a ROM from a path generated by `extract`
#[derive(Args, Clone)]
pub struct Build {
    /// Path to config YAML
    #[arg(long, short = 'c')]
    config: PathBuf,

    /// Nintendo DS ARM7 BIOS file
    #[arg(long, short = '7')]
    arm7_bios: Option<PathBuf>,

    /// Output ROM
    #[arg(long, short = 'o')]
    rom: PathBuf,

    /// Verbose output.
    #[arg(long, short = 'v', default_value_t = false)]
    verbose: bool,
}

impl Build {
    pub fn run(&self) -> Result<()> {
    
        let mut axs = ds_rom::AccessList::new();

        let key = if let Some(arm7_bios) = &self.arm7_bios {
            axs.read( arm7_bios.clone() );
            Some(BlowfishKey::from_arm7_bios_path(arm7_bios)?)
        } else {
            None
        };

        let rom_opts = RomLoadOptions { key: key.as_ref(), ..Default::default() };
        axs.read( self.config.clone() );

        let rom = match Rom::load(&self.config, rom_opts ) {
            Err(RomSaveError::BlowfishKeyNeeded) => {
                bail!("The ROM is encrypted, please provide ARM7 BIOS");
            },
            Err(e) => {
                log::error!("Some other error: {:?}", e);
                bail!("Exiting...");
            },
            Ok( (rom, access) ) => {
                axs.append(&access);
               rom
            },
        };

        let raw_rom = rom.build(key.as_ref())?;
        raw_rom.save(&self.rom)?;
        axs.write( self.rom.clone() );

        if self.verbose {
            axs.print_in_time_order(stdout());
        }

        Ok(())
    }
}
